<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>Stylus Calculator — исправленный холст</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#161616">
<style>
:root {
  --bg: #000;
  --surface: #161616;
  --btn: #222;
  --btn-hover: #333;
  --accent: #ff2e63;
  --text: #fff;
  --radius: 12px;
}
* { box-sizing: border-box; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
body {
  margin:0; background:var(--bg); color:var(--text);
  display:flex; justify-content:center; align-items:flex-start;
  min-height:100vh; padding:.75rem;
}
.container { width:100%; max-width:520px; }
.calc { padding:.5rem; }
#screen { width:100%; font-size:2.1rem; font-weight:600; padding:.8rem; text-align:right;
  background:var(--surface); color:var(--text); border-radius:var(--radius); margin-bottom:.5rem; border:none; }
.canvas-wrap { display:flex; gap:.5rem; align-items:flex-start; margin-bottom:.5rem; }
#draw { flex:1; height:160px; background:#fff; border-radius:var(--radius); border:3px solid var(--accent); touch-action:none; display:block; }
.controls { width:120px; display:flex; flex-direction:column; gap:.5rem; }
.small-btn { padding:.5rem; border-radius:10px; background:#111; color:var(--text); border:none; cursor:pointer; font-size:.9rem; }
.small-btn:active{ background:#222 }
#history { margin-top:.6rem; background:#0e0e0e; padding:.5rem; border-radius:10px; max-height:160px; overflow:auto; font-size:.95rem; }
.hitem { padding:.35rem; border-radius:8px; display:flex; justify-content:space-between; gap:.5rem; align-items:center; cursor:pointer; }
.hitem:hover { background:#111 }

.grid { display:grid; grid-template-columns:repeat(5,1fr); gap:.4rem; margin-top:.5rem; }
button.key { min-height:56px; font-size:1.15rem; border:none; border-radius:10px; background:var(--btn); color:var(--text); cursor:pointer; }
button.key:active{ background:var(--btn-hover) }
button.op { background:var(--accent) }
.span2 { grid-column: span 2; }

.footer { margin-top:.6rem; font-size:0.85rem; color:#aaa; display:flex; justify-content:space-between; align-items:center; }
@media (max-width:480px){ .canvas-wrap{ flex-direction:column } .controls{ width:100%; flex-direction:row; gap:.4rem } }
</style>
</head>
<body>
<div class="container">
  <main class="calc" role="application">
    <input id="screen" readonly placeholder="0" aria-label="Экран калькулятора">

    <div class="canvas-wrap">
      <canvas id="draw" aria-label="Холст для стилуса"></canvas>
      <div class="controls" role="group" aria-label="Управление холстом">
        <button id="clearCanvas" class="small-btn">Очистить</button>
        <button id="undoStroke" class="small-btn">Отменить штрих</button>
        <button id="recognizeBtn" class="small-btn">Распознать</button>
        <button id="togglePen" class="small-btn">Режим: рисовать</button>
      </div>
    </div>

    <section class="buttons">
      <div class="grid">
        <button class="key" id="btn-clear" data-op="clear">C</button>
        <button class="key" data-op="back">⌫</button>
        <button class="key" data-op="(">(</button>
        <button class="key" data-op=")">)</button>
        <button class="key" data-fn="sin">sin</button>

        <button class="key" data-fn="cos">cos</button>
        <button class="key" data-fn="tan">tan</button>
        <button class="key" data-fn="log">log</button>
        <button class="key" data-fn="ln">ln</button>
        <button class="key" data-fn="sqrt">√</button>

        <button class="key" data-op="^">xʸ</button>
        <button class="key" data-val="7">7</button>
        <button class="key" data-val="8">8</button>
        <button class="key" data-val="9">9</button>
        <button class="key op" data-op="÷">÷</button>

        <button class="key" data-val="π">π</button>
        <button class="key" data-val="4">4</button>
        <button class="key" data-val="5">5</button>
        <button class="key" data-val="6">6</button>
        <button class="key op" data-op="×">×</button>

        <button class="key" data-val="e">e</button>
        <button class="key" data-val="1">1</button>
        <button class="key" data-val="2">2</button>
        <button class="key" data-val="3">3</button>
        <button class="key op" data-op="-">-</button>

        <button class="key span2" data-val="0">0</button>
        <button class="key" data-val=".">.</button>
        <button class="key op" data-op="+">+</button>
        <button class="key op" data-op="=">=</button>
      </div>
    </section>

    <div id="history" aria-live="polite"></div>

    <div class="footer">
      <div>История — последние 10 вычислений</div>
      <div>Установить: <span id="installHint">—</span></div>
    </div>
  </main>
</div>

<script>
(function(){
  /* ========= UI и выражение ========= */
  const screen = document.getElementById('screen');
  let expr = '';
  let reset = false;
  const HISTORY_KEY = 'calc_history_v1';
  let history = loadHistory();

  function write(s){ if (reset){ expr=''; reset=false;} expr+=s; screen.value = expr || '0'; }
  function backspace(){ if(!expr) return; expr = expr.slice(0,-1); screen.value = expr || '0'; }
  function clearAll(){ expr=''; screen.value='0'; reset=false; }

  /* ========= Parser (без eval) ========= */
  const Parser = (() => {
    const PI = Math.PI, E = Math.E;
    function tokenize(str){
      str = str.replace(/\s+/g,'');
      const re = /([a-zπe]+|\d+\.?\d*|\.\d+|[+\-*/^(),])/g;
      let m, out=[];
      while((m = re.exec(str))!==null){
        const token = m[1];
        if(token === '-'){
          const prev = out[out.length-1];
          if(!prev || prev === '(' || /^[+\-*/^]$/.test(prev)) out.push('u-');
          else out.push('-');
        } else out.push(token);
      }
      return out;
    }
    function parse(str){
      const t = tokenize(str); let pos=0;
      function peek(){ return t[pos]; }
      function consume(v){ if(peek() !== v) throw new Error('Expected '+v); pos++; }

      function parseAdd(){ let left = parseMul(); while(peek()==='+'||peek()==='-'){ const op=peek(); pos++; const right=parseMul(); left = op==='+'? left+right: left-right; } return left; }
      function parseMul(){ let left = parsePow(); while(peek()==='*'||peek()==='/'){ const op=peek(); pos++; const right=parsePow(); if(op==='/'&& right===0) throw new Error('Division by zero'); left = op==='*'? left*right: left/right; } return left; }
      function parsePow(){ let left = parseUnary(); if(peek()==='^'){ pos++; const right = parsePow(); left = Math.pow(left, right); } return left; }
      function parseUnary(){ if(peek()==='u-'){ pos++; return -parseUnary(); } return parseAtom(); }
      function parseAtom(){
        const v = peek();
        if(v === '('){ pos++; const a = parseAdd(); consume(')'); return a; }
        if(v === 'sin'){ pos++; consume('('); const a=parseAdd(); consume(')'); return Math.sin(a); }
        if(v === 'cos'){ pos++; consume('('); const a=parseAdd(); consume(')'); return Math.cos(a); }
        if(v === 'tan'){ pos++; consume('('); const a=parseAdd(); consume(')'); return Math.tan(a); }
        if(v === 'log'){ pos++; consume('('); const a=parseAdd(); if(a<=0) throw new Error('Log of non-positive number'); consume(')'); return Math.log10(a); }
        if(v === 'ln'){ pos++; consume('('); const a=parseAdd(); if(a<=0) throw new Error('Log of non-positive number'); consume(')'); return Math.log(a); }
        if(v === 'sqrt'){ pos++; consume('('); const a=parseAdd(); if(a<0) throw new Error('Sqrt of negative number'); consume(')'); return Math.sqrt(a); }
        if(v === 'π' || v === 'pi'){ pos++; return PI; }
        if(v === 'e'){ pos++; return E; }
        if(!isNaN(v)){ pos++; return parseFloat(v); }
        throw new Error('Bad token '+v);
      }

      const res = parseAdd();
      if(pos !== t.length) throw new Error('Extra tokens');
      return res;
    }
    return { parse };
  })();

  function calc(){
    try {
      let parseExpr = expr.replace(/×/g,'*').replace(/÷/g,'/');
      if(parseExpr.length > 300) throw new Error('Expression too long');
      const res = Parser.parse(parseExpr);
      let resultStr;
      if (Math.abs(res) < 1e-12) resultStr = '0';
      else if (Math.abs(res) > 1e12) resultStr = res.toExponential(6);
      else resultStr = String(Number(res.toFixed(10)));
      pushHistory({ expr: expr, result: resultStr });
      expr = resultStr; screen.value = expr; reset = true;
    } catch(e) {
      console.error(e);
      screen.value = 'Error'; expr=''; reset = true;
    }
  }

  /* ======= Buttons wiring ======= */
  document.querySelectorAll('button[data-val]').forEach(b=>b.addEventListener('click', ()=>write(b.dataset.val)));
  document.querySelectorAll('button[data-fn]').forEach(b=>b.addEventListener('click', ()=>write(b.dataset.fn + '(')));
  document.querySelectorAll('button[data-op]').forEach(b=>{
    b.addEventListener('click', ()=>{
      const op = b.dataset.op;
      if(op === '=') calc();
      else if(op === 'clear') clearAll();
      else if(op === 'back') backspace();
      else write(op);
    });
  });
  document.getElementById('btn-clear').addEventListener('click', clearAll);
  (function longPressBack(){
    const backBtn = [...document.querySelectorAll('button[data-op]')].find(el=>el.dataset.op==='back');
    let timer;
    backBtn.addEventListener('pointerdown', ()=>{ timer = setTimeout(()=>{ clearAll(); }, 600); });
    backBtn.addEventListener('pointerup', ()=>{ clearTimeout(timer); });
    backBtn.addEventListener('pointerleave', ()=>{ clearTimeout(timer); });
  })();

  /* ========= History (localStorage) ========= */
  const historyEl = document.getElementById('history');
  function loadHistory(){ try{ const raw = localStorage.getItem(HISTORY_KEY); return raw? JSON.parse(raw): []; } catch{ return []; } }
  function saveHistory(){ localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); renderHistory(); }
  function pushHistory(item){ history.unshift(item); if(history.length>10) history.length = 10; saveHistory(); }
  function renderHistory(){
    historyEl.innerHTML = '';
    if(!history.length){ historyEl.textContent = 'Пусто'; return; }
    history.forEach(h=>{
      const el = document.createElement('div'); el.className='hitem';
      el.innerHTML = `<div style="opacity:.95">${escapeHtml(h.expr)}</div><div style="opacity:.85">= ${escapeHtml(h.result)}</div>`;
      el.title = 'Нажмите, чтобы вставить результат';
      el.addEventListener('click', ()=>{ expr = h.result; screen.value = expr; reset = false; });
      historyEl.appendChild(el);
    });
  }
  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  renderHistory();

  /* ========= Canvas drawing (исправления) ========= */
  const canvas = document.getElementById('draw');
  const ctx = canvas.getContext('2d', { alpha: false });
  let drawing = false;
  let lastX = 0, lastY = 0;
  let strokes = []; // array of strokes; each stroke is array of [x,y]
  let curStroke = [];
  let penMode = true;
  let needsRedraw = false;
  let rafId = null;

  // Установим корректный размер с учётом devicePixelRatio
  function resizeCanvas(){
    // get CSS size
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));
    const dpr = window.devicePixelRatio || 1;

    // set internal size in device pixels
    const newW = Math.round(cssW * dpr);
    const newH = Math.round(cssH * dpr);
    if (canvas.width !== newW || canvas.height !== newH) {
      canvas.width = newW;
      canvas.height = newH;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
    }
    // set transform so drawing coord = CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#000';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    redrawAll();
  }

  // ensure resize is called after layout
  window.addEventListener('load', ()=> setTimeout(resizeCanvas, 60));
  window.addEventListener('resize', ()=> { setTimeout(resizeCanvas, 60); });

  function getPos(evt){
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.clientX ?? (evt.touches && evt.touches[0] && evt.touches[0].clientX);
    const clientY = evt.clientY ?? (evt.touches && evt.touches[0] && evt.touches[0].clientY);
    const x = (clientX || 0) - rect.left;
    const y = (clientY || 0) - rect.top;
    return { x, y };
  }

  function start(e){
    if(!penMode) return;
    // For stylus/finger support: capture pointer so move/up still fire if pointer leaves
    if (e.pointerId) canvas.setPointerCapture?.(e.pointerId);
    drawing = true;
    curStroke = [];
    const p = getPos(e);
    lastX = p.x; lastY = p.y;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    curStroke.push([lastX, lastY]);
    needsRedraw = true;
    scheduleFrame();
    e.preventDefault();
  }

  function move(e){
    if(!drawing) return;
    const p = getPos(e);
    // smoother: draw always (but skip tiny jitter)
    const dist = Math.hypot(p.x - lastX, p.y - lastY);
    if(dist > 0.5){
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      lastX = p.x; lastY = p.y;
      curStroke.push([lastX, lastY]);
    }
    needsRedraw = true;
    e.preventDefault();
  }

  function stop(e){
    if(!drawing) return;
    drawing = false;
    if (e && e.pointerId) canvas.releasePointerCapture?.(e.pointerId);
    if(curStroke.length) strokes.push(curStroke.slice());
    curStroke = [];
    // attempt auto-recognize after small pause
    setTimeout(()=> recognize(), 140);
    needsRedraw = true;
    e && e.preventDefault();
  }

  canvas.addEventListener('pointerdown', start);
  canvas.addEventListener('pointermove', move);
  canvas.addEventListener('pointerup', stop);
  canvas.addEventListener('pointercancel', stop);
  canvas.addEventListener('pointerleave', stop);
  canvas.addEventListener('touchstart', e=>e.preventDefault(), { passive:false }); // prevent scroll on touch

  document.getElementById('clearCanvas').addEventListener('click', ()=>{ strokes = []; redrawAll(); });
  document.getElementById('undoStroke').addEventListener('click', ()=>{ strokes.pop(); redrawAll(); });
  document.getElementById('togglePen').addEventListener('click', ()=>{ penMode = !penMode; document.getElementById('togglePen').textContent = penMode ? 'Режим: рисовать' : 'Режим: панель'; });

  function redrawAll(){
    // draw all strokes onto canvas (coords are CSS pixels)
    // clear full canvas (in CSS pixels)
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width, rect.height);
    ctx.beginPath();
    for(const s of strokes){
      if(!s.length) continue;
      ctx.moveTo(s[0][0], s[0][1]);
      for(let i=1;i<s.length;i++) ctx.lineTo(s[i][0], s[i][1]);
    }
    ctx.stroke();
  }

  function scheduleFrame(){
    if(rafId) return;
    rafId = requestAnimationFrame(()=>{ rafId=null; if(needsRedraw) { redrawAll(); needsRedraw=false; } });
  }

  /* ========= Recognition: normalize to 28x28 and template matching ========= */
  const TEMPLATE_SIZE = 28;
  const templateBank = {};
  (function generateTemplates(){
    const off = document.createElement('canvas'); off.width = TEMPLATE_SIZE; off.height = TEMPLATE_SIZE;
    const octx = off.getContext('2d');
    const fonts = ['bold 20px sans-serif','18px sans-serif','22px Arial','italic 20px serif'];
    for(let d=0; d<=9; d++){
      templateBank[d] = [];
      for(const f of fonts){
        octx.clearRect(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);
        octx.fillStyle = 'white'; octx.fillRect(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);
        octx.fillStyle = 'black';
        octx.font = f; octx.textBaseline = 'middle'; octx.textAlign = 'center';
        const dx = (Math.random()-0.5)*1.5; const dy = (Math.random()-0.5)*1.5;
        octx.fillText(String(d), TEMPLATE_SIZE/2 + dx, TEMPLATE_SIZE/2 + dy);
        const data = octx.getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
        const v = [];
        for(let i=0;i<data.length;i+=4){
          const gray = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114);
          v.push((255 - gray)/255);
        }
        const norm = Math.hypot(...v) || 1;
        templateBank[d].push(v.map(x=>x/norm));
      }
    }
  })();

  function extract28(){
    if(strokes.length === 0) return null;
    const rect = canvas.getBoundingClientRect();
    // compute bounding box in CSS pixels
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const s of strokes) for(const p of s){ minX = Math.min(minX, p[0]); minY = Math.min(minY, p[1]); maxX = Math.max(maxX, p[0]); maxY = Math.max(maxY, p[1]); }
    if(!isFinite(minX)) return null;
    const pad = 8;
    minX = Math.max(0, minX - pad); minY = Math.max(0, minY - pad);
    maxX = Math.min(rect.width, maxX + pad); maxY = Math.min(rect.height, maxY + pad);
    const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);

    const big = document.createElement('canvas'); big.width = Math.ceil(w); big.height = Math.ceil(h);
    const bctx = big.getContext('2d');
    bctx.fillStyle = 'white'; bctx.fillRect(0,0,big.width,big.height);
    bctx.strokeStyle = 'black'; bctx.lineCap='round'; bctx.lineJoin='round'; bctx.lineWidth = 6;
    for(const s of strokes){
      if(!s.length) continue;
      bctx.beginPath();
      bctx.moveTo(s[0][0] - minX, s[0][1] - minY);
      for(let i=1;i<s.length;i++) bctx.lineTo(s[i][0] - minX, s[i][1] - minY);
      bctx.stroke();
    }

    const tmp = document.createElement('canvas'); tmp.width = TEMPLATE_SIZE; tmp.height = TEMPLATE_SIZE;
    const tctx = tmp.getContext('2d');
    tctx.fillStyle = 'white'; tctx.fillRect(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);

    // Fit into central 20x20 box like MNIST
    const targetBox = 20;
    const scale = Math.min(targetBox / big.width, targetBox / big.height);
    const drawW = big.width * scale, drawH = big.height * scale;
    const offsetX = (TEMPLATE_SIZE - drawW) / 2;
    const offsetY = (TEMPLATE_SIZE - drawH) / 2;
    tctx.drawImage(big, 0,0,big.width,big.height, offsetX, offsetY, drawW, drawH);

    const img = tctx.getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
    const v = [];
    for(let i=0;i<img.length;i+=4){
      const gray = (img[i]*0.299 + img[i+1]*0.587 + img[i+2]*0.114);
      v.push((255 - gray)/255);
    }
    const norm = Math.hypot(...v) || 1;
    return v.map(x=>x/norm);
  }

  function recognize(){
    const v = extract28();
    if(!v) { strokes = []; redrawAll(); return; }
    let bestDigit = null, bestScore = -Infinity;
    for(let d=0; d<=9; d++){
      for(const tpl of templateBank[d]){
        let s=0;
        for(let i=0;i<tpl.length;i++) s += tpl[i] * v[i];
        if(s > bestScore){ bestScore = s; bestDigit = d; }
      }
    }
    if(bestScore > 0.45){
      write(String(bestDigit));
      setTimeout(()=>{ strokes = []; redrawAll(); }, 220);
    } else {
      // слабая уверенность — просто очистим холст
      setTimeout(()=>{ strokes = []; redrawAll(); }, 300);
    }
  }
  document.getElementById('recognizeBtn').addEventListener('click', recognize);

  /* ========= PWA installation + SW registration ========= */
  let deferredPrompt = null;
  const installHint = document.getElementById('installHint');
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installHint.innerHTML = '<button id="installBtn" class="small-btn">Установить</button>';
    document.getElementById('installBtn').addEventListener('click', async ()=>{
      if(!deferredPrompt) return;
      deferredPrompt.prompt();
      const choice = await deferredPrompt.userChoice;
      deferredPrompt = null;
      installHint.textContent = choice.outcome === 'accepted' ? 'Установлено' : 'Отклонено';
    });
  });

  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('service-worker.js').then(()=>{ console.log('SW registered'); }).catch(err=>console.warn('SW reg failed', err));
  }

  // expose for debug
  window.__stylusCalc = { recognize, pushHistory, history };

})();
</script>
</body>
</html>
